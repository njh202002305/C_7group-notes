2-1의 예제대로 한다면 
char 는 -128에서 127 까지의 범위만 출력할수 있으므로 129를 선언하면
오버플로가 발생한다. 
이를 수정하는 방법은
a를 char로 선언하지 말고 인트로 선언하거나 unsigned char로 선언하면
0에서 2^8까지의 범위를 출력할수 있으므로
a : 2-2의 예제대로 하면 오버플로가 발생할거 같아
2-2의 예재대로 프로그램을 실행한 결과 오버플로가 발생하였다.
b : 오버플로가 발생하는 이유가 뭘까?
a : char 는 -128에서 127까지 범위의 숫자만 출력할수 있는데 129를 선언
하면 이 범위를 벗어나는 숫자기 때문일거야
b : 해결방법은 뭐야?
a : a를 char로 선언하지 말고 int로 선언하거나 unsigned char로 선언하면
0에서 2^8까지의 범위를 출력할수 있으니까 129를 선언하여도 오버플로가
발생하지 않을꺼야
a를 unsigned char로 선언한 결과 오버플로가 발생하지 않았다.

2-2예제
2-2의 예제대로 프로그램을 실행한 결과 구문오류 '상수'가 발생하였다.
a : const는 상수를 지정하는 함수인데 number20을 const로 지정하고
뒤에서 number30으로 다시 지정하는 바람에 오류가 발생한거 같아
const 를 지우면 해결되지 않을까?
const를 지우고 실행한결과 사각형의 면적이0.00000이라는 결과가 나왔다
a : 5.56이라는 값이 소수이니까 short로 선언하면 소수를 반영하지 못하는
거같아 short를 double로 바꿔보자
short length와 short area를 double length와 double area로 바꿔준 결과
사각형의 면적은30.913600입니다. 라고 정상적으로 출력되는것을 확인할 수
있었다.

묵시적 형변환과 명시적 형변환
묵시적 형변환이란 컴파일러에 의해 자동으로 형변환이 이루어지는 것을
말한다. 데이터 값을 잃지 않는 방향으로 이루어지기 때문에
char → short → int → unsigned → long → float → double 순서로만 가능
하다.
a : 묵시적 형변환은 큰 자료형에서 작은 자료형으로 형변환을 하지 못하는
이유가 뭘까?
a : 큰 자료형에서 작은 자료형으로 형변환을 할 경우 데이터의 일부가 
잘려나갈 수 있기 때문인거 같아 프로그램이 임의로 데이터손실을 시킬 수가 
없는거지
b : 그럼 명시적 형변환에서는 가능한 이유는?
a : 형변환을 사용자 스스로 선언하였기 때문에 데이터 손실에 대한 책임을
사용자가 지게 되니까 허용한거 아닐까? 프로그램이 임의로 형변환을 한게
아니기 때문에 데이터 손실에 대한 책임은 프로그램이 아니라 사용자가 
짊어지게 되는거지
